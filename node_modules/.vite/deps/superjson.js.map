{
  "version": 3,
  "sources": ["../../.pnpm/superjson@1.13.3/node_modules/superjson/src/double-indexed-kv.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/registry.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/class-registry.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/util.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/custom-transformer-registry.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/is.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/pathstringifier.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/transformer.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/accessDeep.ts", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/plainer.ts", "../../.pnpm/is-what@4.1.16/node_modules/is-what/dist/index.js", "../../.pnpm/copy-anything@3.0.5/node_modules/copy-anything/dist/index.js", "../../.pnpm/superjson@1.13.3/node_modules/superjson/src/index.ts"],
  "sourcesContent": ["export class DoubleIndexedKV<K, V> {\n  keyToValue = new Map<K, V>();\n  valueToKey = new Map<V, K>();\n\n  set(key: K, value: V) {\n    this.keyToValue.set(key, value);\n    this.valueToKey.set(value, key);\n  }\n\n  getByKey(key: K): V | undefined {\n    return this.keyToValue.get(key);\n  }\n\n  getByValue(value: V): K | undefined {\n    return this.valueToKey.get(value);\n  }\n\n  clear() {\n    this.keyToValue.clear();\n    this.valueToKey.clear();\n  }\n}\n", "import { DoubleIndexedKV } from './double-indexed-kv';\n\nexport class Registry<T> {\n  private kv = new DoubleIndexedKV<string, T>();\n\n  constructor(private readonly generateIdentifier: (v: T) => string) {}\n\n  register(value: T, identifier?: string): void {\n    if (this.kv.getByValue(value)) {\n      return;\n    }\n\n    if (!identifier) {\n      identifier = this.generateIdentifier(value);\n    }\n\n    this.kv.set(identifier, value);\n  }\n\n  clear(): void {\n    this.kv.clear();\n  }\n\n  getIdentifier(value: T) {\n    return this.kv.getByValue(value);\n  }\n\n  getValue(identifier: string) {\n    return this.kv.getByKey(identifier);\n  }\n}\n", "import { Registry } from './registry';\nimport { Class } from './types';\n\nexport interface RegisterOptions {\n  identifier?: string;\n  allowProps?: string[];\n}\n\nexport class ClassRegistry extends Registry<Class> {\n  constructor() {\n    super(c => c.name);\n  }\n\n  private classToAllowedProps = new Map<Class, string[]>();\n\n  register(value: Class, options?: string | RegisterOptions): void {\n    if (typeof options === 'object') {\n      if (options.allowProps) {\n        this.classToAllowedProps.set(value, options.allowProps);\n      }\n\n      super.register(value, options.identifier);\n    } else {\n      super.register(value, options);\n    }\n  }\n\n  getAllowedProps(value: Class): string[] | undefined {\n    return this.classToAllowedProps.get(value);\n  }\n}\n", "function valuesOfObj<T>(record: Record<string, T>): T[] {\n  if ('values' in Object) {\n    // eslint-disable-next-line es5/no-es6-methods\n    return Object.values(record);\n  }\n\n  const values: T[] = [];\n\n  // eslint-disable-next-line no-restricted-syntax\n  for (const key in record) {\n    if (record.hasOwnProperty(key)) {\n      values.push(record[key]);\n    }\n  }\n\n  return values;\n}\n\nexport function find<T>(\n  record: Record<string, T>,\n  predicate: (v: T) => boolean\n): T | undefined {\n  const values = valuesOfObj(record);\n  if ('find' in values) {\n    // eslint-disable-next-line es5/no-es6-methods\n    return values.find(predicate);\n  }\n\n  const valuesNotNever = values as T[];\n\n  for (let i = 0; i < valuesNotNever.length; i++) {\n    const value = valuesNotNever[i];\n    if (predicate(value)) {\n      return value;\n    }\n  }\n\n  return undefined;\n}\n\nexport function forEach<T>(\n  record: Record<string, T>,\n  run: (v: T, key: string) => void\n) {\n  Object.entries(record).forEach(([key, value]) => run(value, key));\n}\n\nexport function includes<T>(arr: T[], value: T) {\n  return arr.indexOf(value) !== -1;\n}\n\nexport function findArr<T>(\n  record: T[],\n  predicate: (v: T) => boolean\n): T | undefined {\n  for (let i = 0; i < record.length; i++) {\n    const value = record[i];\n    if (predicate(value)) {\n      return value;\n    }\n  }\n\n  return undefined;\n}\n", "import { JSONValue } from './types';\nimport { find } from './util';\n\nexport interface CustomTransfomer<I, O extends JSONValue> {\n  name: string;\n  isApplicable: (v: any) => v is I;\n  serialize: (v: I) => O;\n  deserialize: (v: O) => I;\n}\n\nexport class CustomTransformerRegistry {\n  private transfomers: Record<string, CustomTransfomer<any, any>> = {};\n\n  register<I, O extends JSONValue>(transformer: CustomTransfomer<I, O>) {\n    this.transfomers[transformer.name] = transformer;\n  }\n\n  findApplicable<T>(v: T) {\n    return find(this.transfomers, transformer =>\n      transformer.isApplicable(v)\n    ) as CustomTransfomer<T, JSONValue> | undefined;\n  }\n\n  findByName(name: string) {\n    return this.transfomers[name];\n  }\n}\n", "const getType = (payload: any): string =>\n  Object.prototype.toString.call(payload).slice(8, -1);\n\nexport const isUndefined = (payload: any): payload is undefined =>\n  typeof payload === 'undefined';\n\nexport const isNull = (payload: any): payload is null => payload === null;\n\nexport const isPlainObject = (\n  payload: any\n): payload is { [key: string]: any } => {\n  if (typeof payload !== 'object' || payload === null) return false;\n  if (payload === Object.prototype) return false;\n  if (Object.getPrototypeOf(payload) === null) return true;\n\n  return Object.getPrototypeOf(payload) === Object.prototype;\n};\n\nexport const isEmptyObject = (payload: any): payload is {} =>\n  isPlainObject(payload) && Object.keys(payload).length === 0;\n\nexport const isArray = (payload: any): payload is any[] =>\n  Array.isArray(payload);\n\nexport const isString = (payload: any): payload is string =>\n  typeof payload === 'string';\n\nexport const isNumber = (payload: any): payload is number =>\n  typeof payload === 'number' && !isNaN(payload);\n\nexport const isBoolean = (payload: any): payload is boolean =>\n  typeof payload === 'boolean';\n\nexport const isRegExp = (payload: any): payload is RegExp =>\n  payload instanceof RegExp;\n\nexport const isMap = (payload: any): payload is Map<any, any> =>\n  payload instanceof Map;\n\nexport const isSet = (payload: any): payload is Set<any> =>\n  payload instanceof Set;\n\nexport const isSymbol = (payload: any): payload is symbol =>\n  getType(payload) === 'Symbol';\n\nexport const isDate = (payload: any): payload is Date =>\n  payload instanceof Date && !isNaN(payload.valueOf());\n\nexport const isError = (payload: any): payload is Error =>\n  payload instanceof Error;\n\nexport const isNaNValue = (payload: any): payload is typeof NaN =>\n  typeof payload === 'number' && isNaN(payload);\n\nexport const isPrimitive = (\n  payload: any\n): payload is boolean | null | undefined | number | string | symbol =>\n  isBoolean(payload) ||\n  isNull(payload) ||\n  isUndefined(payload) ||\n  isNumber(payload) ||\n  isString(payload) ||\n  isSymbol(payload);\n\nexport const isBigint = (payload: any): payload is bigint =>\n  typeof payload === 'bigint';\n\nexport const isInfinite = (payload: any): payload is number =>\n  payload === Infinity || payload === -Infinity;\n\nexport type TypedArrayConstructor =\n  | Int8ArrayConstructor\n  | Uint8ArrayConstructor\n  | Uint8ClampedArrayConstructor\n  | Int16ArrayConstructor\n  | Uint16ArrayConstructor\n  | Int32ArrayConstructor\n  | Uint32ArrayConstructor\n  | Float32ArrayConstructor\n  | Float64ArrayConstructor;\n\nexport type TypedArray = InstanceType<TypedArrayConstructor>;\n\nexport const isTypedArray = (payload: any): payload is TypedArray =>\n  ArrayBuffer.isView(payload) && !(payload instanceof DataView);\n\nexport const isURL = (payload: any): payload is URL => payload instanceof URL;\n", "export type StringifiedPath = string;\ntype Path = string[];\n\nexport const escapeKey = (key: string) => key.replace(/\\./g, '\\\\.');\n\nexport const stringifyPath = (path: Path): StringifiedPath =>\n  path\n    .map(String)\n    .map(escapeKey)\n    .join('.');\n\nexport const parsePath = (string: StringifiedPath) => {\n  const result: string[] = [];\n\n  let segment = '';\n  for (let i = 0; i < string.length; i++) {\n    let char = string.charAt(i);\n\n    const isEscapedDot = char === '\\\\' && string.charAt(i + 1) === '.';\n    if (isEscapedDot) {\n      segment += '.';\n      i++;\n      continue;\n    }\n\n    const isEndOfSegment = char === '.';\n    if (isEndOfSegment) {\n      result.push(segment);\n      segment = '';\n      continue;\n    }\n\n    segment += char;\n  }\n\n  const lastSegment = segment;\n  result.push(lastSegment);\n\n  return result;\n};\n", "import {\n  isBigint,\n  isDate,\n  isInfinite,\n  isMap,\n  isNaNValue,\n  isRegExp,\n  isSet,\n  isUndefined,\n  isSymbol,\n  isArray,\n  isError,\n  isTypedArray,\n  TypedArrayConstructor,\n  isURL,\n} from './is';\nimport { findArr } from './util';\nimport SuperJSON from '.';\n\nexport type PrimitiveTypeAnnotation = 'number' | 'undefined' | 'bigint';\n\ntype LeafTypeAnnotation =\n  | PrimitiveTypeAnnotation\n  | 'regexp'\n  | 'Date'\n  | 'Error'\n  | 'URL';\n\ntype TypedArrayAnnotation = ['typed-array', string];\ntype ClassTypeAnnotation = ['class', string];\ntype SymbolTypeAnnotation = ['symbol', string];\ntype CustomTypeAnnotation = ['custom', string];\n\ntype SimpleTypeAnnotation = LeafTypeAnnotation | 'map' | 'set';\n\ntype CompositeTypeAnnotation =\n  | TypedArrayAnnotation\n  | ClassTypeAnnotation\n  | SymbolTypeAnnotation\n  | CustomTypeAnnotation;\n\nexport type TypeAnnotation = SimpleTypeAnnotation | CompositeTypeAnnotation;\n\nfunction simpleTransformation<I, O, A extends SimpleTypeAnnotation>(\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\n  annotation: A,\n  transform: (v: I, superJson: SuperJSON) => O,\n  untransform: (v: O, superJson: SuperJSON) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst simpleRules = [\n  simpleTransformation(\n    isUndefined,\n    'undefined',\n    () => null,\n    () => undefined\n  ),\n  simpleTransformation(\n    isBigint,\n    'bigint',\n    v => v.toString(),\n    v => {\n      if (typeof BigInt !== 'undefined') {\n        return BigInt(v);\n      }\n\n      console.error('Please add a BigInt polyfill.');\n\n      return v as any;\n    }\n  ),\n  simpleTransformation(\n    isDate,\n    'Date',\n    v => v.toISOString(),\n    v => new Date(v)\n  ),\n\n  simpleTransformation(\n    isError,\n    'Error',\n    (v, superJson) => {\n      const baseError: any = {\n        name: v.name,\n        message: v.message,\n      };\n\n      superJson.allowedErrorProps.forEach(prop => {\n        baseError[prop] = (v as any)[prop];\n      });\n\n      return baseError;\n    },\n    (v, superJson) => {\n      const e = new Error(v.message);\n      e.name = v.name;\n      e.stack = v.stack;\n\n      superJson.allowedErrorProps.forEach(prop => {\n        (e as any)[prop] = v[prop];\n      });\n\n      return e;\n    }\n  ),\n\n  simpleTransformation(\n    isRegExp,\n    'regexp',\n    v => '' + v,\n    regex => {\n      const body = regex.slice(1, regex.lastIndexOf('/'));\n      const flags = regex.slice(regex.lastIndexOf('/') + 1);\n      return new RegExp(body, flags);\n    }\n  ),\n\n  simpleTransformation(\n    isSet,\n    'set',\n    // (sets only exist in es6+)\n    // eslint-disable-next-line es5/no-es6-methods\n    v => [...v.values()],\n    v => new Set(v)\n  ),\n  simpleTransformation(\n    isMap,\n    'map',\n    v => [...v.entries()],\n    v => new Map(v)\n  ),\n\n  simpleTransformation<number, 'NaN' | 'Infinity' | '-Infinity', 'number'>(\n    (v): v is number => isNaNValue(v) || isInfinite(v),\n    'number',\n    v => {\n      if (isNaNValue(v)) {\n        return 'NaN';\n      }\n\n      if (v > 0) {\n        return 'Infinity';\n      } else {\n        return '-Infinity';\n      }\n    },\n    Number\n  ),\n\n  simpleTransformation<number, '-0', 'number'>(\n    (v): v is number => v === 0 && 1 / v === -Infinity,\n    'number',\n    () => {\n      return '-0';\n    },\n    Number\n  ),\n\n  simpleTransformation(\n    isURL,\n    'URL',\n    v => v.toString(),\n    v => new URL(v)\n  ),\n];\n\nfunction compositeTransformation<I, O, A extends CompositeTypeAnnotation>(\n  isApplicable: (v: any, superJson: SuperJSON) => v is I,\n  annotation: (v: I, superJson: SuperJSON) => A,\n  transform: (v: I, superJson: SuperJSON) => O,\n  untransform: (v: O, a: A, superJson: SuperJSON) => I\n) {\n  return {\n    isApplicable,\n    annotation,\n    transform,\n    untransform,\n  };\n}\n\nconst symbolRule = compositeTransformation(\n  (s, superJson): s is Symbol => {\n    if (isSymbol(s)) {\n      const isRegistered = !!superJson.symbolRegistry.getIdentifier(s);\n      return isRegistered;\n    }\n    return false;\n  },\n  (s, superJson) => {\n    const identifier = superJson.symbolRegistry.getIdentifier(s);\n    return ['symbol', identifier!];\n  },\n  v => v.description,\n  (_, a, superJson) => {\n    const value = superJson.symbolRegistry.getValue(a[1]);\n    if (!value) {\n      throw new Error('Trying to deserialize unknown symbol');\n    }\n    return value;\n  }\n);\n\nconst constructorToName = [\n  Int8Array,\n  Uint8Array,\n  Int16Array,\n  Uint16Array,\n  Int32Array,\n  Uint32Array,\n  Float32Array,\n  Float64Array,\n  Uint8ClampedArray,\n].reduce<Record<string, TypedArrayConstructor>>((obj, ctor) => {\n  obj[ctor.name] = ctor;\n  return obj;\n}, {});\n\nconst typedArrayRule = compositeTransformation(\n  isTypedArray,\n  v => ['typed-array', v.constructor.name],\n  v => [...v],\n  (v, a) => {\n    const ctor = constructorToName[a[1]];\n\n    if (!ctor) {\n      throw new Error('Trying to deserialize unknown typed array');\n    }\n\n    return new ctor(v);\n  }\n);\n\nexport function isInstanceOfRegisteredClass(\n  potentialClass: any,\n  superJson: SuperJSON\n): potentialClass is any {\n  if (potentialClass?.constructor) {\n    const isRegistered = !!superJson.classRegistry.getIdentifier(\n      potentialClass.constructor\n    );\n    return isRegistered;\n  }\n  return false;\n}\n\nconst classRule = compositeTransformation(\n  isInstanceOfRegisteredClass,\n  (clazz, superJson) => {\n    const identifier = superJson.classRegistry.getIdentifier(clazz.constructor);\n    return ['class', identifier!];\n  },\n  (clazz, superJson) => {\n    const allowedProps = superJson.classRegistry.getAllowedProps(\n      clazz.constructor\n    );\n    if (!allowedProps) {\n      return { ...clazz };\n    }\n\n    const result: any = {};\n    allowedProps.forEach(prop => {\n      result[prop] = clazz[prop];\n    });\n    return result;\n  },\n  (v, a, superJson) => {\n    const clazz = superJson.classRegistry.getValue(a[1]);\n\n    if (!clazz) {\n      throw new Error(\n        'Trying to deserialize unknown class - check https://github.com/blitz-js/superjson/issues/116#issuecomment-773996564'\n      );\n    }\n\n    return Object.assign(Object.create(clazz.prototype), v);\n  }\n);\n\nconst customRule = compositeTransformation(\n  (value, superJson): value is any => {\n    return !!superJson.customTransformerRegistry.findApplicable(value);\n  },\n  (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(\n      value\n    )!;\n    return ['custom', transformer.name];\n  },\n  (value, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findApplicable(\n      value\n    )!;\n    return transformer.serialize(value);\n  },\n  (v, a, superJson) => {\n    const transformer = superJson.customTransformerRegistry.findByName(a[1]);\n    if (!transformer) {\n      throw new Error('Trying to deserialize unknown custom value');\n    }\n    return transformer.deserialize(v);\n  }\n);\n\nconst compositeRules = [classRule, symbolRule, customRule, typedArrayRule];\n\nexport const transformValue = (\n  value: any,\n  superJson: SuperJSON\n): { value: any; type: TypeAnnotation } | undefined => {\n  const applicableCompositeRule = findArr(compositeRules, rule =>\n    rule.isApplicable(value, superJson)\n  );\n  if (applicableCompositeRule) {\n    return {\n      value: applicableCompositeRule.transform(value as never, superJson),\n      type: applicableCompositeRule.annotation(value, superJson),\n    };\n  }\n\n  const applicableSimpleRule = findArr(simpleRules, rule =>\n    rule.isApplicable(value, superJson)\n  );\n\n  if (applicableSimpleRule) {\n    return {\n      value: applicableSimpleRule.transform(value as never, superJson),\n      type: applicableSimpleRule.annotation,\n    };\n  }\n\n  return undefined;\n};\n\nconst simpleRulesByAnnotation: Record<string, typeof simpleRules[0]> = {};\nsimpleRules.forEach(rule => {\n  simpleRulesByAnnotation[rule.annotation] = rule;\n});\n\nexport const untransformValue = (\n  json: any,\n  type: TypeAnnotation,\n  superJson: SuperJSON\n) => {\n  if (isArray(type)) {\n    switch (type[0]) {\n      case 'symbol':\n        return symbolRule.untransform(json, type, superJson);\n      case 'class':\n        return classRule.untransform(json, type, superJson);\n      case 'custom':\n        return customRule.untransform(json, type, superJson);\n      case 'typed-array':\n        return typedArrayRule.untransform(json, type, superJson);\n      default:\n        throw new Error('Unknown transformation: ' + type);\n    }\n  } else {\n    const transformation = simpleRulesByAnnotation[type];\n    if (!transformation) {\n      throw new Error('Unknown transformation: ' + type);\n    }\n\n    return transformation.untransform(json as never, superJson);\n  }\n};\n", "import { isMap, isArray, isPlainObject, isSet } from './is';\nimport { includes } from './util';\n\nconst getNthKey = (value: Map<any, any> | Set<any>, n: number): any => {\n  const keys = value.keys();\n  while (n > 0) {\n    keys.next();\n    n--;\n  }\n\n  return keys.next().value;\n};\n\nfunction validatePath(path: (string | number)[]) {\n  if (includes(path, '__proto__')) {\n    throw new Error('__proto__ is not allowed as a property');\n  }\n  if (includes(path, 'prototype')) {\n    throw new Error('prototype is not allowed as a property');\n  }\n  if (includes(path, 'constructor')) {\n    throw new Error('constructor is not allowed as a property');\n  }\n}\n\nexport const getDeep = (object: object, path: (string | number)[]): object => {\n  validatePath(path);\n\n  for (let i = 0; i < path.length; i++) {\n    const key = path[i];\n    if (isSet(object)) {\n      object = getNthKey(object, +key);\n    } else if (isMap(object)) {\n      const row = +key;\n      const type = +path[++i] === 0 ? 'key' : 'value';\n\n      const keyOfRow = getNthKey(object, row);\n      switch (type) {\n        case 'key':\n          object = keyOfRow;\n          break;\n        case 'value':\n          object = object.get(keyOfRow);\n          break;\n      }\n    } else {\n      object = (object as any)[key];\n    }\n  }\n\n  return object;\n};\n\nexport const setDeep = (\n  object: any,\n  path: (string | number)[],\n  mapper: (v: any) => any\n): any => {\n  validatePath(path);\n\n  if (path.length === 0) {\n    return mapper(object);\n  }\n\n  let parent = object;\n\n  for (let i = 0; i < path.length - 1; i++) {\n    const key = path[i];\n\n    if (isArray(parent)) {\n      const index = +key;\n      parent = parent[index];\n    } else if (isPlainObject(parent)) {\n      parent = parent[key];\n    } else if (isSet(parent)) {\n      const row = +key;\n      parent = getNthKey(parent, row);\n    } else if (isMap(parent)) {\n      const isEnd = i === path.length - 2;\n      if (isEnd) {\n        break;\n      }\n\n      const row = +key;\n      const type = +path[++i] === 0 ? 'key' : 'value';\n\n      const keyOfRow = getNthKey(parent, row);\n      switch (type) {\n        case 'key':\n          parent = keyOfRow;\n          break;\n        case 'value':\n          parent = parent.get(keyOfRow);\n          break;\n      }\n    }\n  }\n\n  const lastKey = path[path.length - 1];\n\n  if (isArray(parent)) {\n    parent[+lastKey] = mapper(parent[+lastKey]);\n  } else if (isPlainObject(parent)) {\n    parent[lastKey] = mapper(parent[lastKey]);\n  }\n\n  if (isSet(parent)) {\n    const oldValue = getNthKey(parent, +lastKey);\n    const newValue = mapper(oldValue);\n    if (oldValue !== newValue) {\n      parent.delete(oldValue);\n      parent.add(newValue);\n    }\n  }\n\n  if (isMap(parent)) {\n    const row = +path[path.length - 2];\n    const keyToRow = getNthKey(parent, row);\n\n    const type = +lastKey === 0 ? 'key' : 'value';\n    switch (type) {\n      case 'key': {\n        const newKey = mapper(keyToRow);\n        parent.set(newKey, parent.get(keyToRow));\n\n        if (newKey !== keyToRow) {\n          parent.delete(keyToRow);\n        }\n        break;\n      }\n\n      case 'value': {\n        parent.set(keyToRow, mapper(parent.get(keyToRow)));\n        break;\n      }\n    }\n  }\n\n  return object;\n};\n", "import {\n  isArray,\n  isEmptyObject,\n  isMap,\n  isPlainObject,\n  isPrimitive,\n  isSet,\n} from './is';\nimport { escapeKey, stringifyPath } from './pathstringifier';\nimport {\n  isInstanceOfRegisteredClass,\n  transformValue,\n  TypeAnnotation,\n  untransformValue,\n} from './transformer';\nimport { includes, forEach } from './util';\nimport { parsePath } from './pathstringifier';\nimport { getDeep, setDeep } from './accessDeep';\nimport SuperJSON from '.';\n\ntype Tree<T> = InnerNode<T> | Leaf<T>;\ntype Leaf<T> = [T];\ntype InnerNode<T> = [T, Record<string, Tree<T>>];\n\nexport type MinimisedTree<T> = Tree<T> | Record<string, Tree<T>> | undefined;\n\nfunction traverse<T>(\n  tree: MinimisedTree<T>,\n  walker: (v: T, path: string[]) => void,\n  origin: string[] = []\n): void {\n  if (!tree) {\n    return;\n  }\n\n  if (!isArray(tree)) {\n    forEach(tree, (subtree, key) =>\n      traverse(subtree, walker, [...origin, ...parsePath(key)])\n    );\n    return;\n  }\n\n  const [nodeValue, children] = tree;\n  if (children) {\n    forEach(children, (child, key) => {\n      traverse(child, walker, [...origin, ...parsePath(key)]);\n    });\n  }\n\n  walker(nodeValue, origin);\n}\n\nexport function applyValueAnnotations(\n  plain: any,\n  annotations: MinimisedTree<TypeAnnotation>,\n  superJson: SuperJSON\n) {\n  traverse(annotations, (type, path) => {\n    plain = setDeep(plain, path, v => untransformValue(v, type, superJson));\n  });\n\n  return plain;\n}\n\nexport function applyReferentialEqualityAnnotations(\n  plain: any,\n  annotations: ReferentialEqualityAnnotations\n) {\n  function apply(identicalPaths: string[], path: string) {\n    const object = getDeep(plain, parsePath(path));\n\n    identicalPaths.map(parsePath).forEach(identicalObjectPath => {\n      plain = setDeep(plain, identicalObjectPath, () => object);\n    });\n  }\n\n  if (isArray(annotations)) {\n    const [root, other] = annotations;\n    root.forEach(identicalPath => {\n      plain = setDeep(plain, parsePath(identicalPath), () => plain);\n    });\n\n    if (other) {\n      forEach(other, apply);\n    }\n  } else {\n    forEach(annotations, apply);\n  }\n\n  return plain;\n}\n\nconst isDeep = (object: any, superJson: SuperJSON): boolean =>\n  isPlainObject(object) ||\n  isArray(object) ||\n  isMap(object) ||\n  isSet(object) ||\n  isInstanceOfRegisteredClass(object, superJson);\n\nfunction addIdentity(object: any, path: any[], identities: Map<any, any[][]>) {\n  const existingSet = identities.get(object);\n\n  if (existingSet) {\n    existingSet.push(path);\n  } else {\n    identities.set(object, [path]);\n  }\n}\n\ninterface Result {\n  transformedValue: any;\n  annotations?: MinimisedTree<TypeAnnotation>;\n}\n\nexport type ReferentialEqualityAnnotations =\n  | Record<string, string[]>\n  | [string[]]\n  | [string[], Record<string, string[]>];\n\nexport function generateReferentialEqualityAnnotations(\n  identitites: Map<any, any[][]>,\n  dedupe: boolean\n): ReferentialEqualityAnnotations | undefined {\n  const result: Record<string, string[]> = {};\n  let rootEqualityPaths: string[] | undefined = undefined;\n\n  identitites.forEach(paths => {\n    if (paths.length <= 1) {\n      return;\n    }\n\n    // if we're not deduping, all of these objects continue existing.\n    // putting the shortest path first makes it easier to parse for humans\n    // if we're deduping though, only the first entry will still exist, so we can't do this optimisation.\n    if (!dedupe) {\n      paths = paths\n        .map(path => path.map(String))\n        .sort((a, b) => a.length - b.length);\n    }\n\n    const [representativePath, ...identicalPaths] = paths;\n\n    if (representativePath.length === 0) {\n      rootEqualityPaths = identicalPaths.map(stringifyPath);\n    } else {\n      result[stringifyPath(representativePath)] = identicalPaths.map(\n        stringifyPath\n      );\n    }\n  });\n\n  if (rootEqualityPaths) {\n    if (isEmptyObject(result)) {\n      return [rootEqualityPaths];\n    } else {\n      return [rootEqualityPaths, result];\n    }\n  } else {\n    return isEmptyObject(result) ? undefined : result;\n  }\n}\n\nexport const walker = (\n  object: any,\n  identities: Map<any, any[][]>,\n  superJson: SuperJSON,\n  dedupe: boolean,\n  path: any[] = [],\n  objectsInThisPath: any[] = [],\n  seenObjects = new Map<unknown, Result>()\n): Result => {\n  const primitive = isPrimitive(object);\n\n  if (!primitive) {\n    addIdentity(object, path, identities);\n\n    const seen = seenObjects.get(object);\n    if (seen) {\n      // short-circuit result if we've seen this object before\n      return dedupe\n        ? {\n            transformedValue: null,\n          }\n        : seen;\n    }\n  }\n\n  if (!isDeep(object, superJson)) {\n    const transformed = transformValue(object, superJson);\n\n    const result: Result = transformed\n      ? {\n          transformedValue: transformed.value,\n          annotations: [transformed.type],\n        }\n      : {\n          transformedValue: object,\n        };\n    if (!primitive) {\n      seenObjects.set(object, result);\n    }\n    return result;\n  }\n\n  if (includes(objectsInThisPath, object)) {\n    // prevent circular references\n    return {\n      transformedValue: null,\n    };\n  }\n\n  const transformationResult = transformValue(object, superJson);\n  const transformed = transformationResult?.value ?? object;\n\n  const transformedValue: any = isArray(transformed) ? [] : {};\n  const innerAnnotations: Record<string, Tree<TypeAnnotation>> = {};\n\n  forEach(transformed, (value, index) => {\n    const recursiveResult = walker(\n      value,\n      identities,\n      superJson,\n      dedupe,\n      [...path, index],\n      [...objectsInThisPath, object],\n      seenObjects\n    );\n\n    transformedValue[index] = recursiveResult.transformedValue;\n\n    if (isArray(recursiveResult.annotations)) {\n      innerAnnotations[index] = recursiveResult.annotations;\n    } else if (isPlainObject(recursiveResult.annotations)) {\n      forEach(recursiveResult.annotations, (tree, key) => {\n        innerAnnotations[escapeKey(index) + '.' + key] = tree;\n      });\n    }\n  });\n\n  const result: Result = isEmptyObject(innerAnnotations)\n    ? {\n        transformedValue,\n        annotations: !!transformationResult\n          ? [transformationResult.type]\n          : undefined,\n      }\n    : {\n        transformedValue,\n        annotations: !!transformationResult\n          ? [transformationResult.type, innerAnnotations]\n          : innerAnnotations,\n      };\n  if (!primitive) {\n    seenObjects.set(object, result);\n  }\n\n  return result;\n};\n", "function getType(payload) {\n  return Object.prototype.toString.call(payload).slice(8, -1);\n}\n\nfunction isAnyObject(payload) {\n  return getType(payload) === \"Object\";\n}\n\nfunction isArray(payload) {\n  return getType(payload) === \"Array\";\n}\n\nfunction isBlob(payload) {\n  return getType(payload) === \"Blob\";\n}\n\nfunction isBoolean(payload) {\n  return getType(payload) === \"Boolean\";\n}\n\nfunction isDate(payload) {\n  return getType(payload) === \"Date\" && !isNaN(payload);\n}\n\nfunction isEmptyArray(payload) {\n  return isArray(payload) && payload.length === 0;\n}\n\nfunction isPlainObject(payload) {\n  if (getType(payload) !== \"Object\")\n    return false;\n  const prototype = Object.getPrototypeOf(payload);\n  return !!prototype && prototype.constructor === Object && prototype === Object.prototype;\n}\n\nfunction isEmptyObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length === 0;\n}\n\nfunction isEmptyString(payload) {\n  return payload === \"\";\n}\n\nfunction isError(payload) {\n  return getType(payload) === \"Error\" || payload instanceof Error;\n}\n\nfunction isFile(payload) {\n  return getType(payload) === \"File\";\n}\n\nfunction isFullArray(payload) {\n  return isArray(payload) && payload.length > 0;\n}\n\nfunction isFullObject(payload) {\n  return isPlainObject(payload) && Object.keys(payload).length > 0;\n}\n\nfunction isString(payload) {\n  return getType(payload) === \"String\";\n}\n\nfunction isFullString(payload) {\n  return isString(payload) && payload !== \"\";\n}\n\nfunction isFunction(payload) {\n  return typeof payload === \"function\";\n}\n\nfunction isType(payload, type) {\n  if (!(type instanceof Function)) {\n    throw new TypeError(\"Type must be a function\");\n  }\n  if (!Object.prototype.hasOwnProperty.call(type, \"prototype\")) {\n    throw new TypeError(\"Type is not a class\");\n  }\n  const name = type.name;\n  return getType(payload) === name || Boolean(payload && payload.constructor === type);\n}\n\nfunction isInstanceOf(value, classOrClassName) {\n  if (typeof classOrClassName === \"function\") {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (isType(p, classOrClassName)) {\n        return true;\n      }\n    }\n    return false;\n  } else {\n    for (let p = value; p; p = Object.getPrototypeOf(p)) {\n      if (getType(p) === classOrClassName) {\n        return true;\n      }\n    }\n    return false;\n  }\n}\n\nfunction isMap(payload) {\n  return getType(payload) === \"Map\";\n}\n\nfunction isNaNValue(payload) {\n  return getType(payload) === \"Number\" && isNaN(payload);\n}\n\nfunction isNumber(payload) {\n  return getType(payload) === \"Number\" && !isNaN(payload);\n}\n\nfunction isNegativeNumber(payload) {\n  return isNumber(payload) && payload < 0;\n}\n\nfunction isNull(payload) {\n  return getType(payload) === \"Null\";\n}\n\nfunction isOneOf(a, b, c, d, e) {\n  return (value) => a(value) || b(value) || !!c && c(value) || !!d && d(value) || !!e && e(value);\n}\n\nfunction isUndefined(payload) {\n  return getType(payload) === \"Undefined\";\n}\n\nconst isNullOrUndefined = isOneOf(isNull, isUndefined);\n\nfunction isObject(payload) {\n  return isPlainObject(payload);\n}\n\nfunction isObjectLike(payload) {\n  return isAnyObject(payload);\n}\n\nfunction isPositiveNumber(payload) {\n  return isNumber(payload) && payload > 0;\n}\n\nfunction isSymbol(payload) {\n  return getType(payload) === \"Symbol\";\n}\n\nfunction isPrimitive(payload) {\n  return isBoolean(payload) || isNull(payload) || isUndefined(payload) || isNumber(payload) || isString(payload) || isSymbol(payload);\n}\n\nfunction isPromise(payload) {\n  return getType(payload) === \"Promise\";\n}\n\nfunction isRegExp(payload) {\n  return getType(payload) === \"RegExp\";\n}\n\nfunction isSet(payload) {\n  return getType(payload) === \"Set\";\n}\n\nfunction isWeakMap(payload) {\n  return getType(payload) === \"WeakMap\";\n}\n\nfunction isWeakSet(payload) {\n  return getType(payload) === \"WeakSet\";\n}\n\nexport { getType, isAnyObject, isArray, isBlob, isBoolean, isDate, isEmptyArray, isEmptyObject, isEmptyString, isError, isFile, isFullArray, isFullObject, isFullString, isFunction, isInstanceOf, isMap, isNaNValue, isNegativeNumber, isNull, isNullOrUndefined, isNumber, isObject, isObjectLike, isOneOf, isPlainObject, isPositiveNumber, isPrimitive, isPromise, isRegExp, isSet, isString, isSymbol, isType, isUndefined, isWeakMap, isWeakSet };\n", "import { isArray, isPlainObject } from 'is-what';\n\nfunction assignProp(carry, key, newVal, originalObject, includeNonenumerable) {\n  const propType = {}.propertyIsEnumerable.call(originalObject, key) ? \"enumerable\" : \"nonenumerable\";\n  if (propType === \"enumerable\")\n    carry[key] = newVal;\n  if (includeNonenumerable && propType === \"nonenumerable\") {\n    Object.defineProperty(carry, key, {\n      value: newVal,\n      enumerable: false,\n      writable: true,\n      configurable: true\n    });\n  }\n}\nfunction copy(target, options = {}) {\n  if (isArray(target)) {\n    return target.map((item) => copy(item, options));\n  }\n  if (!isPlainObject(target)) {\n    return target;\n  }\n  const props = Object.getOwnPropertyNames(target);\n  const symbols = Object.getOwnPropertySymbols(target);\n  return [...props, ...symbols].reduce((carry, key) => {\n    if (isArray(options.props) && !options.props.includes(key)) {\n      return carry;\n    }\n    const val = target[key];\n    const newVal = copy(val, options);\n    assignProp(carry, key, newVal, target, options.nonenumerable);\n    return carry;\n  }, {});\n}\n\nexport { copy };\n", "import { Class, JSONValue, SuperJSONResult, SuperJSONValue } from './types';\nimport { ClassRegistry, RegisterOptions } from './class-registry';\nimport { Registry } from './registry';\nimport {\n  CustomTransfomer,\n  CustomTransformerRegistry,\n} from './custom-transformer-registry';\nimport {\n  applyReferentialEqualityAnnotations,\n  applyValueAnnotations,\n  generateReferentialEqualityAnnotations,\n  walker,\n} from './plainer';\nimport { copy } from 'copy-anything';\n\nexport default class SuperJSON {\n  /**\n   * If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.\n   */\n  private readonly dedupe: boolean;\n\n  /**\n   * @param dedupeReferentialEqualities  If true, SuperJSON will make sure only one instance of referentially equal objects are serialized and the rest are replaced with `null`.\n   */\n  constructor({\n    dedupe = false,\n  }: {\n    dedupe?: boolean;\n  } = {}) {\n    this.dedupe = dedupe;\n  }\n\n  serialize(object: SuperJSONValue): SuperJSONResult {\n    const identities = new Map<any, any[][]>();\n    const output = walker(object, identities, this, this.dedupe);\n    const res: SuperJSONResult = {\n      json: output.transformedValue,\n    };\n\n    if (output.annotations) {\n      res.meta = {\n        ...res.meta,\n        values: output.annotations,\n      };\n    }\n\n    const equalityAnnotations = generateReferentialEqualityAnnotations(\n      identities,\n      this.dedupe\n    );\n    if (equalityAnnotations) {\n      res.meta = {\n        ...res.meta,\n        referentialEqualities: equalityAnnotations,\n      };\n    }\n\n    return res;\n  }\n\n  deserialize<T = unknown>(payload: SuperJSONResult): T {\n    const { json, meta } = payload;\n\n    let result: T = copy(json) as any;\n\n    if (meta?.values) {\n      result = applyValueAnnotations(result, meta.values, this);\n    }\n\n    if (meta?.referentialEqualities) {\n      result = applyReferentialEqualityAnnotations(\n        result,\n        meta.referentialEqualities\n      );\n    }\n\n    return result;\n  }\n\n  stringify(object: SuperJSONValue): string {\n    return JSON.stringify(this.serialize(object));\n  }\n\n  parse<T = unknown>(string: string): T {\n    return this.deserialize(JSON.parse(string));\n  }\n\n  readonly classRegistry = new ClassRegistry();\n  registerClass(v: Class, options?: RegisterOptions | string) {\n    this.classRegistry.register(v, options);\n  }\n\n  readonly symbolRegistry = new Registry<Symbol>(s => s.description ?? '');\n  registerSymbol(v: Symbol, identifier?: string) {\n    this.symbolRegistry.register(v, identifier);\n  }\n\n  readonly customTransformerRegistry = new CustomTransformerRegistry();\n  registerCustom<I, O extends JSONValue>(\n    transformer: Omit<CustomTransfomer<I, O>, 'name'>,\n    name: string\n  ) {\n    this.customTransformerRegistry.register({\n      name,\n      ...transformer,\n    });\n  }\n\n  readonly allowedErrorProps: string[] = [];\n  allowErrorProps(...props: string[]) {\n    this.allowedErrorProps.push(...props);\n  }\n\n  private static defaultInstance = new SuperJSON();\n  static serialize = SuperJSON.defaultInstance.serialize.bind(\n    SuperJSON.defaultInstance\n  );\n  static deserialize = SuperJSON.defaultInstance.deserialize.bind(\n    SuperJSON.defaultInstance\n  );\n  static stringify = SuperJSON.defaultInstance.stringify.bind(\n    SuperJSON.defaultInstance\n  );\n  static parse = SuperJSON.defaultInstance.parse.bind(\n    SuperJSON.defaultInstance\n  );\n  static registerClass = SuperJSON.defaultInstance.registerClass.bind(\n    SuperJSON.defaultInstance\n  );\n  static registerSymbol = SuperJSON.defaultInstance.registerSymbol.bind(\n    SuperJSON.defaultInstance\n  );\n  static registerCustom = SuperJSON.defaultInstance.registerCustom.bind(\n    SuperJSON.defaultInstance\n  );\n  static allowErrorProps = SuperJSON.defaultInstance.allowErrorProps.bind(\n    SuperJSON.defaultInstance\n  );\n}\n\nexport { SuperJSON };\n\nexport const serialize = SuperJSON.serialize;\nexport const deserialize = SuperJSON.deserialize;\n\nexport const stringify = SuperJSON.stringify;\nexport const parse = SuperJSON.parse;\n\nexport const registerClass = SuperJSON.registerClass;\nexport const registerCustom = SuperJSON.registerCustom;\nexport const registerSymbol = SuperJSON.registerSymbol;\nexport const allowErrorProps = SuperJSON.allowErrorProps;\n"],
  "mappings": "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",
  "names": ["DoubleIndexedKV", "Registry", "ClassRegistry", "CustomTransformerRegistry", "__read", "walker", "__spreadArray", "__read", "getType", "isArray", "getType", "isPlainObject", "getType", "isNull", "getType", "isUndefined", "isArray", "isPlainObject", "SuperJSON", "_a", "__assign", "__spreadArray", "__read"]
}
